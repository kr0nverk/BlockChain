_# BlockChain
## Введение

Блокче́йн — выстроенная по определённым правилам непрерывная последовательная цепочка блоков, содержащих информацию. Связь между блоками обеспечивается не только нумерацией, но и тем, что каждый блок содержит свою собственную хеш-сумму и хеш-сумму предыдущего блока. Изменение любой информации в блоке изменит его хеш-сумму.

Технологию активно внедряют и она очень попуярна в наше время, потому что она решает несколько задач:
- защита конфиденциальности — банки и платежные системы знают сумму сделки, как зовут отправителей и получателей, то блокчейн сохраняет анонимность;
- обеспечение безопасности — данные сохраняются на всех блоках в цепи, поэтому полностью удалить или изменить какую-либо запись в системе невозможно;
- бесперебойная работа — сеть функционирует благодаря группе участников, занимающихся майнингом. Если центральный сервер из-за технических работ или проблем с электричеством может временно выйти из строя, то блокчейн будет работать всегда;

Кроме того, блокчейн гарантирует прозрачность сделок благодаря смарт-контрактам. Это программный код, в котором зафиксированы условия. Он позволяет отказаться от лишних посредников, взимающих комиссии. Смарт-контракт невозможно изменить, а операция выполняется автоматически.

## Что вам необходимо?
Нужно установить Python 3+. Вам также необходимо установить библиотеку Flask:
```commandline
pip install Flask
```

## Код
Мы создадим класс блокчейна, чей конструктор создает начальный пустой лист (для хранения нашего блокчейна), и еще один — для хранения транзакций. Вот чертёж нашего класса:
- def \_\_init\_\_(self):
- def new\_block(self):
- def new\_transaction(self):
- def hash(block):
- def last\_block(self):

Наш класс Blockchain отвечает за управление цепью. Он будет хранить транзакции, а также иметь несколько вспомогательных методов для внесения новых блоков в цепь. Начнем с работы с несколькими методами.

Каждый блок содержит индекс, временной штамп (время unix), список транзакций, доказательство (об этом позже) и хеш предыдущего блока.

С этого момента, понимание цепи должно быть раздельным — каждый новый блок содержит внутри себя хеш предыдущего блока. Это принципиально важно, так как этим обеспечивается неизменность блокчейна: если злоумышленник взломает предыдущий блок, то все остальные блоки будут содержать неправильные хеши.

Нам нужен будет способом внесения транзакций в блок. Наш метод new\_transaction() отвечает за это, и он достаточно прямолинейный.

После того, как new\_transaction() внесет транзакцию в список, он вернет индекс блока, в которой должна будет быть внесена транзакция — а именно следующая. В будущем, это будет полезно для пользователя, отправляющего транзакцию.

Создание новых блоков
После того, как мы получили экземпляр блокчейна, нам нужно посадить в него блок генезиса — первый блок без предшественников. Нам также нужно внести “пруф” в наш блок генезиса, который представляет собой результат майнинга (доказательства проведенной работы). Мы рассмотрим майнинг позже.

В дополнению к созданию блока генезиса в конструкторе, мы также выкатим методы для new\_block(), new\_transaction() и hash():

Алгоритм пруфа работы (Proof of Work, PoW) — это то, как новые блоки созданы или майнятся в блокчейне. Цель PoW — это найти число, которое решает проблему. Число должно быть таким, чтобы его тяжело было найти, но легко подтвердить (говоря о вычислениях) кем угодно в интернете. Это главная задача алгоритма.

Давайте реализуем аналогичный алгоритм для нашего блокчейна.

- def proof\_of\_work(self, last\_proof):
- def valid\_proof(last\_proof, proof):

Чтобы скорректировать сложность алгоритма, мы можем изменить количество заглавных нулей. В нашем случае, 4 — достаточно. Вы узнаете, что внесение одного ведущего нуля создает колоссальную разницу во времени, необходимом для поиска решения (майнинга).

Наш класс практически готов, так что мы можем начать взаимодействовать с ним через HTTP запросы.

Здесь мы задействуем фреймворк под названием Flask. Это макро-фреймворк, который заметно упрощает сопоставление конечных точек с функциями Python. Это позволяет нам взаимодействовать с нашим блокчейном в интернете при помощиHTTP-запросов.

Мы создадим три метода:
- /transactions/new для создания новой транзакции в блоке;
- /mine, чтобы указать серверу, что нужно майнить новый блок;
- /chain для возвращения всего блокчейна

Конечная точка майнинга — это часть, где происходит магия, и это просто! Для этого нужно сделать три вещи:
- Подсчитать PoW;
- Наградить майнера (нас), добавив транзакцию, дающую нам 1 коин;
- Слепить следующий блок, внеся его в цепь.

Вы можете использовать старый добрый cURL или Postman для взаимодействия с нашим API в сети. Запустим наш сервер:

```
{
    "chain": [
        {
            "index": 1,
            "previous_hash": 1,
            "prof": 100,
            "timestamp": 1670272882.6266901,
            "transaction": []
        }
    ],
    "length": 1
}
```

Давайте попробуем майнить блок, создав GET-запрос к узлу http://localhost:5000/mine:

```
{
    "index": 2,
    "message": "New Block Add",
    "previous_hash": "853afaec44d0873d4f3fab2e2eed25ce84d016d70a898575139094e1af2f6a53",
    "prof": 888273,
    "transaction": [
        {
            "amount": 1,
            "recipient": "dab3128648b5443d9c5a22c75181998a",
            "sender": "0"
        }
    ]
}
```

Теперь, давайте создадим новую транзакцию, отправив POST-запрос к узлу http://localhost:5000/transactions/new с телом, содержащим структуру нашей транзакции:

```
{
 "sender": "dab3128648b5443d9c5a22c75181998a",
 "recipient": "someone",
 "amount": 5
}
```

```
{
    "message": "Add to blockchain3"
}
```
Если вы не пользуетесь Postman, тогда вы можете создать аналогичный запрос при помощи cURL






















